package com.github.cwilper.fcrepo.cloudsync.service.dao;

import com.github.cwilper.fcrepo.cloudsync.api.ObjectSet;
import com.github.cwilper.fcrepo.cloudsync.service.backend.ObjectQuery;
import com.github.cwilper.fcrepo.cloudsync.service.util.StringUtil;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;

public class ObjectSetDao extends AbstractDao {

    private static final String CREATE_DDL =
          "CREATE TABLE ObjectSets (\n"
        + "  id INTEGER PRIMARY KEY NOT NULL GENERATED BY DEFAULT AS IDENTITY,\n"
        + "  name VARCHAR(256) NOT NULL,\n"
        + "  type VARCHAR(32) NOT NULL,\n"
        + "  data VARCHAR(32672) NOT NULL,\n"
        + "  CONSTRAINT ObjectSetUniqueName unique (name))";

    public ObjectSetDao(JdbcTemplate db) {
        super(db);
    }

    @Override
    public void initDb() {
        db.execute(CREATE_DDL);
        ObjectSet o = new ObjectSet();
        o.setName("All Objects");
        o.setType("pidPattern");
        o.setData("*");
        createObjectSet(o);
    }

    public ObjectSet createObjectSet(ObjectSet objectSet)
            throws DuplicateKeyException {
        // normalize and validate fields
        if (StringUtil.normalize(objectSet.getId()) != null) {
            throw new IllegalArgumentException("Specifying the Object Set "
                    + "id during creation is not permitted");
        }
        objectSet.setName(StringUtil.validate("name", objectSet.getName(), 256));
        objectSet.setType(StringUtil.validate("type", objectSet.getType(), 32));
        objectSet.setData(StringUtil.validate("data", objectSet.getData(), 32672));
        new ObjectQuery(objectSet); // do type-specific validation
        String id = insert(
                "INSERT INTO ObjectSets (name, type, data) VALUES (?, ?, ?)",
                objectSet.getName(),
                objectSet.getType(),
                objectSet.getData());
        return getObjectSet(id);
    }

    public List<ObjectSet> listObjectSets() {
        return db.query("SELECT * FROM ObjectSets",
                new RowMapper<ObjectSet>() {
                    public ObjectSet mapRow(ResultSet rs, int i) throws SQLException {
                        return getObjectSet(rs);
                    }
                });
    }

    public ObjectSet getObjectSet(String id) {
        return db.query("SELECT * FROM ObjectSets WHERE id = ?",
                new ResultSetExtractor<ObjectSet>() {
                    public ObjectSet extractData(ResultSet rs)
                            throws SQLException {
                        if (rs.next()) {
                            return getObjectSet(rs);
                        } else {
                            return null;
                        }
                    }
                },
                Integer.parseInt(id));
    }

    private static ObjectSet getObjectSet(ResultSet rs) throws SQLException {
        ObjectSet o = new ObjectSet();
        o.setId("" + rs.getInt("id"));
        o.setName(rs.getString("name"));
        o.setType(rs.getString("type"));
        o.setData(rs.getString("data"));
        return o;
    }

    public ObjectSet updateObjectSet(String id, ObjectSet objectSet) {
        // TODO: Implement me...which fields can be updated?
        return objectSet;
    }

    public void deleteObjectSet(String id) {
        db.update("DELETE FROM ObjectSets WHERE id = ?", Integer.parseInt(id));
    }

}